#!/usr/bin/env node
const { execSync } = require('child_process');
const https = require('https');
const fs = require('fs');
const path = require('path');

function run(cmd) {
    return execSync(cmd, { encoding: 'utf8' }).trim();
}

const token = process.env.GITHUB_TOKEN;
if (!token) {
    console.error('GITHUB_TOKEN is required in the environment to create a PR.');
    console.error(
        'Create a token with `repo` scope and run: GITHUB_TOKEN=... node scripts/create-pr.js',
    );
    process.exit(2);
}

const repoUrl = run('git config --get remote.origin.url');
// repoUrl may be in multiple formats; extract owner/repo
let m = repoUrl.match(/[:/]([^/]+)\/([^/.]+)(?:\.git)?$/);
if (!m) {
    console.error('Could not parse repository URL from git remote.origin.url:', repoUrl);
    process.exit(3);
}
const owner = m[1];
const repo = m[2];

const branch = run('git rev-parse --abbrev-ref HEAD');

// Simple arg parsing for named flags --title, --body, --patch-pr
function readFlag(name) {
    const idx = process.argv.indexOf(name);
    if (idx >= 0 && idx + 1 < process.argv.length) return process.argv[idx + 1];
    return undefined;
}

const titleFlag = readFlag('--title');
const bodyFlag = readFlag('--body');
const patchPrNumber = readFlag('--patch-pr');

// Build a reasonable default title from the branch and latest commit(s)
function defaultTitle() {
    const shortBranch = branch.replace(/[^a-zA-Z0-9-_/.]/g, '-');
    const headCommit = run('git log -1 --pretty=%s');
    return `${shortBranch}: ${headCommit}`;
}

function defaultBody() {
    // Try to get the last 5 commits on this branch; keep command simple to avoid shell expansion issues
    let commits = '';
    try {
        commits = run('git log --pretty=format:"%h %s" -n 5');
    } catch (e) {
        commits = '(could not list commits)';
    }
    return `This PR contains the following commits from branch ${branch}:\n\n${commits}\n\nGenerated by scripts/create-pr.js`;
}

const title = titleFlag || defaultTitle();
const body = bodyFlag || defaultBody();

// Helper to GET repo metadata and obtain default_branch
function getRepoMeta(
    urlStr = `https://api.github.com/repos/${owner}/${repo}`,
    redirectsLeft = 5,
    callback,
) {
    const url = new URL(urlStr);
    const opts = {
        hostname: url.hostname,
        port: url.port || 443,
        path: url.pathname + url.search,
        method: 'GET',
        headers: {
            'User-Agent': 'shiny-palm-tree-bot',
            Authorization: `token ${token}`,
            Accept: 'application/vnd.github.v3+json',
        },
    };

    const req = https.request(opts, (res) => {
        let data = '';
        res.on('data', (d) => (data += d));
        res.on('end', () => {
            // follow redirects for 301/302/307
            if (
                (res.statusCode === 301 || res.statusCode === 302 || res.statusCode === 307) &&
                redirectsLeft > 0
            ) {
                const loc = res.headers.location;
                if (loc) {
                    console.log(
                        `Following repo-meta redirect to ${loc} (status ${res.statusCode})`,
                    );
                    return getRepoMeta(loc, redirectsLeft - 1, callback);
                }
            }

            if (res.statusCode >= 200 && res.statusCode < 300) {
                try {
                    const json = JSON.parse(data);
                    return callback(null, json);
                } catch (e) {
                    return callback(e);
                }
            }
            return callback(new Error(`Failed to fetch repo meta: ${res.statusCode}`));
        });
    });
    req.on('error', (e) => callback(e));
    req.end();
}

const postData = JSON.stringify({
    title,
    head: branch,
    base: 'main',
    body,
});

function doRequest(urlStr, payload, method = 'POST', redirectsLeft = 5) {
    const url = new URL(urlStr);
    const opts = {
        hostname: url.hostname,
        port: url.port || 443,
        path: url.pathname + url.search,
        method,
        headers: {
            'User-Agent': 'shiny-palm-tree-bot',
            Authorization: `token ${token}`,
            Accept: 'application/vnd.github.v3+json',
            'Content-Type': 'application/json',
            'Content-Length': Buffer.byteLength(payload || ''),
        },
    };

    const req = https.request(opts, (res) => {
        let data = '';
        res.on('data', (d) => (data += d));
        res.on('end', () => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
                const json = JSON.parse(data);
                console.log('PR created:', json.html_url);
                process.exit(0);
            }

            // Follow redirects (307/301/302) when GitHub returns a moved response
            if (
                (res.statusCode === 307 || res.statusCode === 301 || res.statusCode === 302) &&
                redirectsLeft > 0
            ) {
                const loc = res.headers.location;
                if (loc) {
                    console.log(`Following redirect to ${loc} (status ${res.statusCode})`);
                    // retry against the new URL (preserve method)
                    return doRequest(loc, payload, method, redirectsLeft - 1);
                }
            }

            console.error('Failed to create PR. Status:', res.statusCode);
            try {
                console.error(JSON.parse(data));
            } catch (e) {
                console.error(data);
            }
            process.exit(4);
        });
    });

    req.on('error', (e) => {
        console.error('Request error:', e);
        process.exit(5);
    });

    req.write(payload);
    req.end();
}

// Helper to find an existing PR number for this branch
function findPrForBranch(meta, callback) {
    const url = `https://api.github.com/repos/${owner}/${repo}/pulls?head=${owner}:${branch}&state=open`;
    const urlObj = new URL(url);
    const opts = {
        hostname: urlObj.hostname,
        port: urlObj.port || 443,
        path: urlObj.pathname + urlObj.search,
        method: 'GET',
        headers: {
            'User-Agent': 'shiny-palm-tree-bot',
            Authorization: `token ${token}`,
            Accept: 'application/vnd.github.v3+json',
        },
    };
    const req = https.request(opts, (res) => {
        let data = '';
        res.on('data', (d) => (data += d));
        res.on('end', () => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
                try {
                    const arr = JSON.parse(data);
                    return callback(null, arr[0] && arr[0].number);
                } catch (e) {
                    return callback(e);
                }
            }
            return callback(new Error('Failed to list PRs: ' + res.statusCode));
        });
    });
    req.on('error', (e) => callback(e));
    req.end();
}

// Main flow: determine default branch, then create or patch PR
getRepoMeta(undefined, 5, (err, meta) => {
    const base = err ? 'main' : meta && meta.default_branch ? meta.default_branch : 'main';
    const url = `https://api.github.com/repos/${owner}/${repo}/pulls`;
    const payload = JSON.stringify({ title, head: branch, base, body });

    // If user requested a specific PR number to patch, do it directly
    if (patchPrNumber) {
        const patchUrl = `https://api.github.com/repos/${owner}/${repo}/pulls/${patchPrNumber}`;
        return doRequest(patchUrl, JSON.stringify({ title, body }), 'PATCH');
    }

    // Otherwise check if a PR already exists for this branch and patch it; else create
    findPrForBranch(meta, (err2, existingPrNumber) => {
        if (err2) {
            console.error('Error checking existing PRs:', err2.message || err2);
            // fallback: attempt to create
            return doRequest(url, payload);
        }
        if (existingPrNumber) {
            console.log(`PR already exists (#${existingPrNumber}) - patching title/body`);
            const patchUrl = `https://api.github.com/repos/${owner}/${repo}/pulls/${existingPrNumber}`;
            return doRequest(patchUrl, JSON.stringify({ title, body }), 'PATCH');
        }
        // create new PR
        doRequest(url, payload);
    });
});
